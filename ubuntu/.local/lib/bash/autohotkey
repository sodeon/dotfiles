#!/bin/bash
#-----------------------------------------------------------------------------------------------
# Parameters
#-----------------------------------------------------------------------------------------------
source $HOME/.config/autohotkeyrc


#-----------------------------------------------------------------------------------------------
# Autohotkey library
#-----------------------------------------------------------------------------------------------
activeWinId() {
    windowId=`xdotool getactivewindow`
    result=$?
    echo $windowId
    return $result
}

# @param class/title name
# @param ahk_title
isWinActive() {
    if [[ -z ${2-} ]]; then # class
        xprop -id $(xdotool getactivewindow) | grep -q WM_CLASS.*=.*$1
        return $?
    elif [[ ${2-} == "ahk_command" ]]; then
        xprop -id $(xdotool getactivewindow) | grep -q WM_COMMAND.*=.*$1
        return $?
    else # ahk_title
        title=`xdotool getactivewindow getwindowname`
        if echo $title | grep -E $1; then
            return 0
        else
            return 1
        fi
    fi
}

# @param class name
winExist() {
    xdotool search --class $1
    return $?
}

winActivate() {
    if [[ -z ${2-} ]]; then
        xdotool search --class $1 windowactivate
    else
        xdotool search --name  $1 windowactivate
    fi
}

isActiveWinFloating() {
    xprop -id $(xdotool getactivewindow) | grep -q "WM_STATE.*STICKY"
}

isWorkspaceEmpty() {
    (! xdotool getactivewindow) || isActiveWinFloating
}

# xdotool with the ability to bypass i3 keygrabbing
xdotool-forward() {
    i3-msg 'mode " "'
    xdotool $@
    i3-msg 'mode "default"'
}

wake-on-lan() {
    machine=$1
    if !(wol $machine); then
        notify-send -t 5000 -u critical "Wake Up Failed" "$machine"
        return 1
    fi
    notify-send.sh -t 0 -r 19 -u low "Waiting For Remote" "$machine"
    for i in {1..5}; do
        if ping -c1 $machine; then
            notify-send.sh -t $notificationTimeout -r 19 -u low "$machine Awake Now"
            return
        fi
    done
    notify-send.sh -t $notificationTimeout -r 19 -u critical "Remote Timeout" $machine
    return 1
}

# NOTE: Entries must use the variable name $entries
simple-rofi() {
    local title="$1"; shift
    local width="$1"; shift
    # local entries=($@) # Bash does not support array function argument. Use $entries variable name to hack/pass the $entries to function

    rofiEntries=""
    for entry in "${entries[@]}"; do
        [ -z $rofiEntries ] \
            && rofiEntries="$entry" \
            || rofiEntries="$rofiEntries\n$entry"
    done

    echo `echo -e "$rofiEntries" | rofi -p "$title" -i -width -$width $rofiStyles`
}


#-----------------------------------------------------------------------------------------------
# Shortcut implementation
#-----------------------------------------------------------------------------------------------
deleteWord() {
	if isWinActive URxvt; then
        xte 'keyup p' 'keydown Control_L' 'key w' 'keyup Control_L'
	else
        xte 'keyup p' 'keydown Control_L' 'key BackSpace' 'keyup Control_L'
	fi
}

deleteWordAfter() {
	if isWinActive URxvt; then
        xte 'keyup i' 'keyup Mode_switch' 'key Escape' 'key d' 'keydown Mode_switch' # escape->d is the same as alt+d in terminal
	else
        xte 'keyup i' 'keydown Control_L' 'key Delete' 'keyup Control_L'
	fi
}

deleteLine() {
	if isWinActive URxvt \
       || isWinActive Code; then
        xte 'keyup u' 'keydown Control_L' 'key u' 'keyup Control_L'
	else
        # ctrl+shift+backspace (delete before) and ctrl+shift+del (delete after)
        xte 'keyup u' 'keydown Control_L' 'keydown Shift_L' 'key BackSpace' 'key Delete' 'keyup Shift_L' 'keyup Control_L'
	fi
}

closeTabOrWindow() {
    if isWinActive $browserWinClass; then
        xte 'keydown Control_L' 'key w' 'keyup Control_L'
    else
        xte 'keydown Alt_L' 'key grave' 'keyup Alt_L'
    fi
}

# floatingToggled() {
#     # When mpv got focused (mpv always floating), go to full screen
#     if isWinActive mpv; then
#         i3-msg fullscreen
#     fi
# }

pageup() {
    if isWinActive $browserWinClass || isWinActive VIM$ ahk_title; then
        xdotool key ctrl+b
    elif isWinActive URxvt; then
		xdotool key shift+Prior
    else
        xdotool key Prior
    fi
}

pagedown() {
    if isWinActive $browserWinClass || isWinActive VIM$ ahk_title; then
        xdotool key ctrl+f
    elif isWinActive URxvt; then
		xdotool key shift+Next
    else
        xdotool key Next
    fi
}

scroll() {
    if isWinActive URxvt && ! isWinActive VIM$ ahk_title; then
		xdotool keyup $2 key shift+$1
    else
        xdotool keyup $2 key $1
    fi
}

play() { # Play if there is any paused media
    if cmus-remote -Q | grep -q "status paused"; then # Ubuntu cmus is not compiled with mpris support
		cmus-remote -p && pkill -RTMIN+12 i3blocks
    elif mpris2controller Status | grep -q "Paused"; then
        mpris2controller PlayPause
    fi
}

pause() { # Pause if there is any playing media
    if cmus-remote -Q | grep -q "status playing"; then # Ubuntu cmus is not compiled with mpris support
		cmus-remote -U && pkill -RTMIN+12 i3blocks
    elif mpris2controller Status | grep -q "Playing"; then
        mpris2controller PlayPause
    fi
}

playPause() { # Play, pause toggle
    if cmus-remote -Q | grep -q -e "status playing" -e "status paused"; then # Ubuntu cmus is not compiled with mpris support
		cmus-remote -u && pkill -RTMIN+12 i3blocks
    else
        mpris2controller PlayPause
    fi
}

nextTrack() {
    if cmus-remote -Q | grep -q "status playing"; then # Ubuntu cmus is not compiled with mpris support
		cmus-remote -n && pkill -RTMIN+12 i3blocks
    else
        mpris2controller Next
    fi
}

prevTrack() {
    if cmus-remote -Q | grep -q "status playing"; then # Ubuntu cmus is not compiled with mpris support
		cmus-remote -r && pkill -RTMIN+12 i3blocks
    else
        mpris2controller Previous
    fi
}

#
# i3 and VIM navigation integration (navigation/movement/resizing)
#
focusWindow() {
    direction=$1
	case $direction in
		left)
			navKey=h;;
		right)
			navKey=l;;
		up)
			navKey=k;;
		down)
			navKey=j;;
	esac
    if isWinActive VIM$ ahk_title || isWinActive "^vim " ahk_title \
       || isWinActive Code \
       || isWinActive ^Notebook$ ahk_title \
       || isWinActive ^tmux$ ahk_title \
       || isWinActive '^/usr/libexec/login.sh ' ahk_title; then
        xdotool-forward keyup $navKey key $navKey
    elif isWinActive ^ranger ahk_title && [[ $direction == 'left' || $direction == 'right' ]]; then
        xdotool-forward keyup $navKey key $navKey
    else
		i3-msg "focus $direction"
    fi
}

moveWindow() {
    direction=$1
	case $direction in
		left)
			navKey=h;;
		right)
			navKey=l;;
		up)
			navKey=k;;
		down)
			navKey=j;;
	esac
    if isWinActive VIM$ ahk_title || isWinActive "^vim " ahk_title \
       || isWinActive Code \
       || isWinActive ^Notebook$ ahk_title \
       || isWinActive ^tmux$ ahk_title; then
        xdotool-forward keyup $navKey key $navKey
    else
		i3-msg "move $@"
    fi
}

resizeWindow() {
    direction="$1 $2"
	case $direction in
		"shrink width")
			navKey=h;;
		"grow width")
			navKey=l;;
		"grow height")
			navKey=k;;
		"shrink height")
			navKey=j;;
	esac
    if isWinActive VIM$ ahk_title || isWinActive "^vim " ahk_title \
       || isWinActive Code \
       || isWinActive ^Notebook$ ahk_title \
       || isWinActive ^tmux$ ahk_title; then
        echo "${@:3}" > /tmp/vim-tmux-i3-integration # Passing size parameters to be consumed.
        xdotool-forward keyup $navKey key $navKey
    else
		i3-msg "resize $@"
    fi
}

# Use app's built-in fullscreen mode if available
toggleFullscreen() {
    if (isWinActive $browserWinClass); then
        if (isWinActive YouTube ahk_title || isWinActive Twitch ahk_title || isWinActive bilibili ahk_title || isWinActive Netflix ahk_title); then
            xte 'key f'
        else
            xte 'key F11'
            # i3-msg "fullscreen toggle"
        fi
    elif isWinActive Code; then # Toggle zen mode for vscode
        xdotool key ctrl+shift+z
    else
        i3-msg "fullscreen toggle"
    fi
    #i3-msg "fullscreen toggle"
}

mediaPlayerFullscreen() {
    i3-msg '[class="^mpv"] fullscreen toggle, scratchpad show'
    # i3-msg '[class="^mpv"] fullscreen toggle' && i3-msg '[class=mpv] scratchpad show'
    # i3-msg '[class="^mpv"] scratchpad show' && sleep 1.5 && i3-msg '[class="^mpv"] fullscreen'
}

workspacePicker() { i3-switch-workspace -monitor -3 -width -17 -no-fixed-num-lines -me-select-entry MouseSecondary -me-accept-entry MousePrimary -theme arc-dark-workspace-switcher.rasi; }

F1() {
    i3-msg 'workspace number "1: Web "'

    if i3-msg -t get_workspaces | jq '.[] | select(.num == 1) .focused' | grep 'true'; then
        if ! xdotool getactivewindow; then
            launchBrowser
        fi
    fi
}

F2() {
    i3-msg 'workspace number "2: Term "'

    if i3-msg -t get_workspaces | jq '.[] | select(.num == 2) .focused' | grep 'true'; then
        if ! xdotool getactivewindow; then
            urxvtc &
        fi
    fi
}

F3() {
    i3-msg 'workspace number "3: File "'

    If workspace 3 has no ranger instance, create one
    if i3-msg -t get_workspaces | jq '.[] | select(.num == 3) .focused' | grep 'true'; then
        if ! isWinActive ranger ahk_command; then
            urxvtc -e ranger $HOME & # ranger default editor: $HOME/.selected_editor; (or export VISUAL=vim;)
        fi
    fi
}

F4() {
    entries=("${f4Entries[@]}")

    i3-msg 'workspace number "4: Code "'

    if i3-msg -t get_workspaces | jq '.[] | select(.num == 4) .focused' | grep 'true'; then
        if ! xdotool getactivewindow; then
            selection=`simple-rofi Program 30 ${entries[@]}`
            [ -z $selection ] && i3-msg "workspace back_and_forth" && return
            
            case "$selection" in
                ${entries[0]})
                    code --disable-gpu # Disable GPU acceleration for VSCode. It has less memory footprint and better UI responsiveness on my machines.
                    ;;
            esac
        fi
    fi
}

F10() {
    entries=("${f10Entries[@]}")

    i3-msg 'workspace number "10: G "'

    if i3-msg -t get_workspaces | jq '.[] | select(.num == 10) .focused' | grep 'true'; then
        if ! xdotool getactivewindow; then
            selection=`simple-rofi Program 20 ${entries[@]}`
            if [ -z $selection ]; then
                i3-msg "workspace back_and_forth"
            else
                $selection
            fi
        fi
    fi
}

toggleMouseMode() {
    file='/tmp/mouse-alt'
    if [ -f $file ]; then
        rm $file
        notify-send.sh --close=10 # notify-send.sh supports expiration time and closing notifications (https://askubuntu.com/questions/110969/notify-send-ignores-timeout)
    else
        touch $file
        notify-send.sh -t 0 -r 10 -u critical Alt Mouse
    fi

    activate-hotkeys
}


#-----------------------------------------------------------------------------------------------
# Hardware control
#-----------------------------------------------------------------------------------------------
volume() {
    if [ $1 = "up" ]; then
        amixer -D pulse set Master 3%+
    elif [ $1 = "down" ]; then
        amixer -D pulse set Master 3%-
    elif [ $1 = "toggle" ]; then
        amixer -D pulse set Master toggle
    fi
    if [ `pulsemixer --get-mute` -eq 1 ]; then
        notify-send.sh -t $notificationTimeout -r 21 -u low Mute Volume
    else
        local volume=`pulsemixer --get-volume | sed -r 's/\s+.*$//'`
        # notify-send.sh -s 21 # Workaround notify-send.sh sometimes will not close volume notification
        notify-send.sh -t $notificationTimeout -r 21 -u low $volume Volume
    fi
    pkill -RTMIN+10 i3blocks
}

brightness() {
    if [ $1 = "up" ]; then
        monitor-control bu | xargs -d '\n' notify-send.sh -t $notificationTimeout -r 22 -u low && pkill -RTMIN+11 i3blocks
    elif [ $1 = "down" ]; then
        monitor-control bd | xargs -d '\n' notify-send.sh -t $notificationTimeout -r 22 -u low && pkill -RTMIN+11 i3blocks
    elif [ $1 = "toggle" ]; then
        monitor-control bs | xargs -d '\n' notify-send.sh -t $notificationTimeout -r 22 -u low && pkill -RTMIN+11 i3blocks
    elif [ $1 = "gaming" ]; then
        monitor-control bg | xargs -d '\n' notify-send.sh -t $notificationTimeout -r 22 -u low && pkill -RTMIN+11 i3blocks
    else
        monitor-control b  | xargs -d '\n' notify-send.sh -t $notificationTimeout -r 22 -u low && pkill -RTMIN+11 i3blocks
    fi
} 

display-input() {
    feature_id=60
    # inputs=(0xf 0x1) # 0x1: D-Sub, 0xf: DP, 0x11: HDMI-1, 0x12: HDMI2, append first item for easier loop logic (no wrap around)

    notify-send.sh -u normal -r 101 "Switching display input..." # ddcutil is slow on NVIDIA graphics, add notification to ease slow responsieness
    if [[ $1 != "toggle" ]]; then
        ddcutil setvcp $feature_id $1
    else
        cur_input=`ddcutil getvcp 60 | awk '{print $NF}' | sed -e 's/.*=//' -e 's/)//'` # Get current input ID
        displayInputs[${#displayInputs[@]}]=${displayInputs[0]}
        hit=0
        for input in ${displayInputs[@]}; do
            [ $hit -eq 1 ] && ddcutil setvcp $feature_id $input && break
            [[ $input -eq $cur_input ]] && hit=1 && continue
        done
    fi
    notify-send.sh --close=101
}

suspend() {
    notify-send.sh -u critical -r 99 "Preparing to suspend..."
    sleep 0.7
    notify-send.sh --close=99
    systemctl suspend
}

display-standby() {
    sleep 0.3
    xset dpms force off
}

bluetooth-quick-connect() { toggle-bluetooth device $quickConnectMac; }
# bluetooth-quick-connect() { toggle-bluetooth device $quickConnectMac true; }

power-menu() {
    entries=("${powerEntries[@]}")

    selection=`simple-rofi Menu 20 ${entries[@]}`
    [ -z $selection ] && return
    
    case "$selection" in
        ${entries[0]})
            xset dpms force off
            ;;
        ${entries[1]})
            systemctl suspend
            ;;
        ${entries[2]})
            reboot
            ;;
        ${entries[3]})
            shutdown -h now
            ;;
    esac
}

bluetooth-menu() {
    entries=("${bluetoothEntries[@]}")

    selection=`simple-rofi Bluetooth 28 ${entries[@]}`
    [ -z $selection ] && return
    
    case "$selection" in
        ${entries[0]})
            toggle-bluetooth
            ;;
        ${entries[1]})
            bluetooth-quick-connect
            ;;
    esac
}

wol-menu() {
    entries=("${wolEntries[@]}")

    selection=`simple-rofi Machine 15 ${entries[@]}`
    [ -z $selection ] && return

    wake-on-lan $selection
}


#-----------------------------------------------------------------------------------------------
# Execute
# TODO: Input validation
#-----------------------------------------------------------------------------------------------
[[ $# == 0 ]] || $@


# Deprecated: result is unreliable. e.g. getting incorrect pid from sxiv
# activeWinPid() {
#     pid=`xdotool getactivewindow getwindowpid`
#     result=$?
#     echo $pid
#     return $result
# }
